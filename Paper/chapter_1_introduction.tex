%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%                                                                 %
%                            CHAPTER                              %
%                                                                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

\chapter{Introduction}
\label{chapter:introduction}

% TODO: Add introduction text

The earliest academic definition of a knowledge graph can be found in a 1974 article as \begin{quote}
    A mathematical structure with vertices as knowledge units connected by edges that represent the prerequisite relation \citep{Marchi1974,bergman2019common}
\end{quote} 

The idea of expressing knowledge in a graph structure predates even this definition, with the concept of semantic networks \citep{Richens1956PreprogrammingFM}. % this is in the ago of punch card computers, so quite impressive 
However, the term knowledge graph only became well-known after Google announced they were using a knowledge graph to enhance their search engine in 2012 \citep{singhal2012introducing}. 
Knowledge graphs are used to make search engines, chatbots, question answering systems, etc more intelligent by injecting knowledge into them \citep{SurveyOnKGs}. 

These knowledge graphs are constructed by extracting information from various sources, both unstructured sources such as text (using natural language processing) and (semi-)structured sources such as databases, CSV, XML, JSON, RDF (using mapping languages). Many mapping languages exist, some with a specific purpose, such as R2RML \citep{Das:12:RRR} for relational databases, XSPARQL \citep{Bischof2012} for XML. Others are more general, such as RML \citep{dimou_ldow_2014} and D2RML \citep{Chortaras2018D2RMLIH}, having the ability to map from multiple sources in different formats. 

To achieve this these mapping languages use a declarative approach, where the user specifies the mapping rules, and the implementation of the mapping language takes care of the actual mapping. Creating these mapping rules is often done by hand. There are tools that make creating these mappings easier, like RMLEditor \citep{heyvaert_jws_2018} and YARRRML \citep{10.1007/978-3-319-98192-5_40}. Alternatively tools exist for automatic generation of mapping rules \textit{cite some tools}.
% TODO: do this citing

Retrieving data from a knowledge graph, for consumption by other programs, is done by querying the knowledge graph using SPARQL \citep{Seaborne:08:SQL} for tabular data and XSPARQL \citep{Bischof2012} or XSLT for XML. XSPARQL is the only language that can both map[/lift] and query[/lower], but the syntax for mapping and querying differs, so it could be argued that XSPARQL is actually two languages.

Because of this disconnection between creating and consuming knowledge graphs, much potential is left untapped. We can not use knowledge graphs flexibly as an intermediate representation for data, as we can not convert the knowledge graph back to the original data format using the same rules we created it with, if the data format has a method for querying[/lowering] at all. As such any changes we make to the data are hard to propagate back to the original data. We can not update, expand or improve the original data using e.g. knowledge graph refining. Nor can we apply changes to a virtual knowledge graph to change the original data. 

We aim to improve this situation by extending an existing system implementation with the ability to invert the mapping rules, i.e. mapping the RDF knowledge graph back to raw data (\textit{RQ2}). We choose to extend the Morph-KGC implementation \citep{arenas2022morph} of RML \citep{dimou_ldow_2014} as its end-to-end characteristics make it a good candidate for this task. 
We also explore how we can leverage RML to construct raw data from heterogeneous data (\textit{RQ1, but this is pretty vague, I could do with a more detailed explanation of what exactly the end goal of this RQ is}). 


\section{Thesis outline}
This thesis aims to explore the possibility of inverting knowledge graphs back to their original data format using RML mapping rules. To achieve this we will first look at the current state of the art in chapter \ref{chapter:related_work}. We will take a closer look at the technologies used like RDF, SPARQL, and RML. We will also look at the current state of the art for inverting knowledge graphs. In chapter \ref{chapter:implementation} we will look at our implementation of the inversion algorithm. We will look at the algorithm itself, and the implementation details. In chapter \ref{chapter:evaluation} we will evaluate our implementation using various benchmarks. For basic testing we use a subset of the rml test cases, which are designed to test the conformance of tools to the RML specification. For more advanced testing we will use various benchmarks simulating real-life use cases like LUBM4OBDA, GTFS-Madrid-Bench and SDM-Genomic-dataset. Finally in chapter \ref{chapter:conclusion} we will conclude this thesis, and look at possible future work.